##Development

	NOTE: github上显示不出markdown批注，请以RAW方式查看

###开发实践

在这个项目中，我全程采用XP的TDD开发方式，使用python BDD库behave作为ATDD的延伸来驱动开发。
用watchmedo来监听源码文件的变化，结合nose、coverage、behave进行自动化测试。
在此之前你必须安装这些开发依赖库:

	pip install --requirement requirement-dev.txt

实时测试，及时获得开发过程反馈，增量迭代的进行开发，都是敏捷开发提到的相关好处，有兴趣朋友可以参考相关资料。

涉及测试的脚本可以参考以下地方:

```
tests/
	features/
		steps/
	units/
	.behaverc
	setup.cfg
	Makefile
	w2d-base.sh*
	w2d-bdd.sh*
	w2d-unittest.sh*
```

###执行测试

```
$ # BDD测试，执行features目录下的功能测试，配置文件可以看tests/.behaverc
$ cd tests
$ make bdd

$ # 单元测试，执行units目录下的测试用例，配置文件看tests/setup.cfg
$ make unit
```

###自动化脚本
wd-base.sh 简单包装了watchmedo命令为watch2do，为以下命令提供简单的使用方法，

	$ # 监控源码以及tests/features文档的BDD自动化测试
	$ cd tests
	$ ./w2d-bdd.sh
	
	$ # 健康源码以及tests/unit下的单元自动化测试
	$ ./w2d-unittest

##测试驱动开发

我的TDD开发步骤，是在基本的**Red-Green-Refacting**下结合BDD一起实施ATDD实践的

1. **Red**: 编写失败的测试用例的test方法
	1. 编写BDD测试，捕捉大体需求；文档包括feature文档和翻译feature的steps文档；
	2. 编写unittest测试，捕捉代码原型的设计；
	3. 以上两测试只要达到能够驱动下一步流程即可，不用很详细，下一步Green下会继续完善当前test；
2. **Green**: 编写可以通过测试的生产代码
	1. 编写生产代码，让之前的测试通过
	2. 继续补充test的不同边界情况
	3. 重复执行Green，直至当前测试基本符合BDD feature文档所描述的内容
3. **Refacting**: 在保持测试通过情况下，重构代码
	1. 发现代码的异味：以消除重复代码、增强代码可读性和发掘代码的模式为视角[^1]
	2. 小步快跑地修改一点，而后执行测试，马上得到反馈结果（此步骤过程一般维持在几十秒到几分钟不等）
	3. 再次操作3.1-3.2，直至代码最简化和可读性最佳，则本次test就可以认为完成
4. 继续补全测试用例(TestCase)的其他场景(Scenario)

上面的1-3针对的是一个小test的步骤，而一个完整功能(Feature)需要有背景(Background)和由不同的场景(Scenario)来阐述[^1]，所以接下来需要继续完善BDD的feature文档，驱动接下来的开发，当然还是重复TDD的**Red-Green-Refacting**，基本上一个功能就可以这么简单的一路驱动走下去直至完成，再也不用抓破头皮去想到底从哪里着手开发了。

###为什么要采用TDD？

关于为什么采用TDD，基本的要素你可以从很多资深程序员的经验总结中得到，如鲍勃大叔会在他涉及的很多作品中都会不厌其烦地跟你介绍，在这我说一下我的看法：

Kent Back在《[测试驱动开发][book-tdd]》《[解析极限编程][book-xpe]》书中都提到过压力绞， `压力越大-->测试越少-->缺陷越多-->压力越大`，如果引入测试之后压力绞自然就会不再，`压力越大-->测试越多-->缺陷越少-->压力减少`，测试(TDD)为什么能够减少开发者压力，我自己有过实际的体会。

编写BDD/TDD整个过程基本上就是编写需求文档&系统领域知识设计和编码设计&实施，这些文档一旦形成就真实反映当前源码的状态，跟源代码同步。日后这些文档就不是程序员的负担，反而是很好的维护需求的助手和传递领域知识、学习源码的工具。

当然前提是需要不断的维护，一旦需求变更，源码随之需要更改；而源码不期而至的被修改后，必须要符合需求文档，所以要验证修改的操作有没有对之前的代码和需求产生副作用。这两项行为都反映出维护需求文档和源代码是必要的行为，而不是多余和浪费时间的工作。

在源码变更后执行BDD/TDD所写的feature和unittest，这类文档就会立马成为捕获变更的防护网，帮你收集变更所涉及所有代码变异点和功能需求点（历史需求的冲突，或上下文的发展情况），而牵一发动全身的后顾之忧就不再，你会变得更有勇气引入新功能和重构源码。显然压力便随着有节奏的编码流程和可预知结果的测试覆盖率得到缓解。[^2]

在没有接触TDD之前的工作，在新开发、重构甚至简单的修改代码，上线前总感到心惊肉跳，生怕稍有闪失导致不可预知的后果。出现这种现象通常是以往自我感觉良好的自己，经历过一次次因为自己生产出来的bug而被半夜事故唤醒的经历，或屡次晨后综合征[^7]的应验而导致的神经衰弱。必须要承认一点，作为程序员的我们会犯错，甚至会犯低级错误，过往的自信其实没有什么可以站得住脚。专业人士会承认自己不可避免地犯错，所以他们会寻求避免犯错的方法，来保证自己的工作得到自己和大家的信任。

在众多XP实践中我觉得TDD是其中的一个不错的实践。在自己过往实施TDD的工作中，我最直观的体会是开发工作量没有增加多少的情况下，维护压力和时间都减少了许多，还有自信心提高什么的，这些都只能通过亲身实施后才能够体会得到的效果。

###测试的TestCase需要说明的:

1. TestCase可以维护开发的上下文。跟随着生产代码保留下来，这些TestCase可以随着项目的不断扩充，而很好地充当维护项目上下文的需求管理员[^3]，
2. TestCase需要不停重构和维护。如果不持续重构TestCase，那么TestCase就会慢慢变得冗余隐晦、难以理解，并且进一步增加开发者的阅读负担和削弱持续跟进的，TestCase写得好的话相可以替代需求文档，就更容易地衔接需求和开发，维护其他就像维护需求文档一样

###为什么加入BDD？[^5]：

1. BDD是描述用户故事--User Story的一份很好的需求文档，故事是学习、沟通和记忆的最有效工具。
2. BDD是商业价值驱动的。BDD是特定领域语言，能将领域知识转换成为源代码，可以消除自然语言的奇异，需求制定人和开发人员都能够无障碍地了解到真正的需求
3. BDD是可验收测试的活文档。与源代码结合后能够反映系统代码的真实情况，同时也是反映需求的系统验收标准。


[^1]: 在BDD中，这正是以用户故事--User Story来捕捉功能需求的最好的体现
[^2]: 《[google时代的工作方法](http://book.douban.com/subject/6510686/)》中有对压力的描述：“紊乱无序让你感到重重压力,重重压力让你举措失当,举措失当让你承受更大的压力,更大的压力让你更加失误连连。这真是 ‘恶性循环’的一个完美定义“。所以有序有节奏的工作能够减轻压力，我想这就是TDD的**Red-Green-Refacting**所能起到的积极作用、以及增加测试减少压力能够增加勇气的原因
[^3]: 我们都知道，上下文对于一个开发者非常重要，它或许由于一次打断或时间的推移不断的模糊和异化，而之前写的TestCase可以帮你记录为什么你要写这些测试的动因，以及将要怎么做，这也是了解项目代码库的宝贵资源！
[^5]: 可以参考《[实例化需求--团队如何交付正确的软件](http://book.douban.com/subject/11611022/)》第一部分
[^7]: 晨后综合征的出处我忘记了，好像是鲍勃大叔的《程序员的职业素养》


[book-tdd]: http://book.douban.com/subject/1230036/ "测试驱动开发"
[book-xpe]: http://book.douban.com/subject/6828074/ "解析极限编程"
[book-gw]: http://book.douban.com/subject/6510686/ "google时代的工作方法"
[book-tdp]: http://book.douban.com/subject/5326182/ "测试驱动开发的艺术"

